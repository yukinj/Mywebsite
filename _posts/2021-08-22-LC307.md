---
layout: post
title: 307. Range Sum Query - Mutable
gh-badge: [star, fork, follow]
tags: [Array, Design, Segment Tree, Fenwick]
comments: true
---

```python
class TreeNode:
    def __init__(self,s,e):
        self.start = s # start end point 
        self.end = e # end endpoint 
        self.total = 0 # total sum within range [start, end] inclusive  
        self.left = None  # left subtree 
        self.right = None # right substree
class NumArray:
    """
    create  tree tc O(N)  sc O(N)
    update/ query  tree tc O(lgN) 
    
    """
    def __init__(self, A: List[int]):
        
        def build_tree(A,s,e):
            if s > e:
                return 
            node = TreeNode(s,e)
            if s == e:
                node.total = A[s]
                return node
            mid = (s+e)//2
            node.left = build_tree(A,s,mid)
            node.right = build_tree(A,mid+1,e)
            
            node.total = node.left.total + node.right.total
            
            return node
        
        self.root = build_tree(A,0,len(A)-1)

    def update(self, index: int, val: int) -> None:
        # update at position index => need to (1)find exact leaf node to update  (2) update related parent node's total  
        def helper_update(node,i,val):
            # if not node: # leaf nodes termination 
            #     return 
            if node.start == node.end: #== i: # target node update   
                node.total = val 
                return
            else:
                mid = (node.start + node.end)//2
                if i <= mid:
                    helper_update(node.left,i,val) # query range falls in left subtree
                else:
                    helper_update(node.right,i,val)# query range falls in right subtree
                node.total = node.left.total + node.right.total   # update current parent node's total       
                return 

        helper_update(self.root, index, val)


    def sumRange(self, left: int, right: int) -> int:
        """
        four cases:  (1) left right is exactly match current node's start, end  range
                     (2) right is within [start, mid] range 
                     (3) left is within [mid+1, end] range
                     (4) cross start end range 
        """
        def helper_srange(node,l,r)-> int:
            # if not node:
            #     return 
             # termination condition:  query range match current root 
            if node.start == l and node.end == r:
                return node.total
            mid = (node.start + node.end)//2
            if r <= mid:
                return helper_srange(node.left,l,r)
            elif l >= mid + 1:
                return helper_srange(node.right,l,r)
            else:
            # otherwise inteval is split  => need to calculate sum recursively 
            # by splitting interval 
                return helper_srange(node.left,l,mid) + helper_srange(node.right,mid+1,r)
                
        return helper_srange(self.root,left,right)
```