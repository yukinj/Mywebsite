---
layout: post
title: 1574. Shortest Subarray to be Removed to Make Array Sorted
gh-repo: yukinj
gh-badge: [star, fork, follow]
tags: [Array, Sliding Window, Binary Search]
comments: true
---
```python
class Solution:
    def findLengthOfShortestSubarray(self, A: List[int]) -> int:
        """
        1.left -ã€‹ right, find first point not increasing 
        2. right -> left, find first point not decreasing 
        3. get base length, shrinking window two points
        4. compare A[i] A[j]: if A[i]< A[j]  i++ else, j--; meanwhile updating min subarray to be removed 
        tc O(N) sc O(1)
        """
        
        n = len(A)
        l,r = -1,-1
        for i in range(n-1):
            if A[i] > A[i+1]:
                l = i
                break
        if l == -1:return 0   # all non-decreasing
        for i in range(n-1,0,-1):
            if A[i] < A[i-1]:
                r = i
                break
            # if A[i] >= A[i-1]:
            #     continue
            # else:
            #     r = i 
            #     break
        # if r == 1:
        #     return n-1
        min_d = min(r,n-l-1) # min_d is at most min(A[:right] or A[left+1:])
        # left start from 0, go to right until reaches left  
        i,j = 0, r
        while i <= l and j < n:
            if A[i] <= A[j]: # window is shrinking   
                min_d = min(min_d,j-i-1)
                i += 1
            else:
                j += 1
        return min_d

```

Two round 
```python
class Solution:
    def findLengthOfShortestSubarray(self, A: List[int]) -> int:
        """
        1. right -> left, find first point not decreasing 
        2. left start from 0 to r, keep until subarray ending with left is not non-decreasing 
        3. within left pointer's while loop, check if A[l] <=A[r], otherwise, right += 1
        4. each time left move one step, update min distance to be removed
        * note the edge cases (all increasing, all decreasing ) and left pointer's termination condition at last loop
        tc O(N) sc O(1)
        """
        
        n = len(A)
        l,r = 0,n-1

        for i in range(n-1,0,-1):
            if A[i] < A[i-1]:
                r = i
                break
        res = r
        while l < r and (l == 0 or A[l-1]<=A[l]):
            while r < n and A[r] < A[l]:
                r += 1
            res = min(res,r-l-1)
            l += 1 

        return res 
        
        
```