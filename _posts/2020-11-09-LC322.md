---
layout: post
title: 322. Coin Change
gh-badge: [star, fork, follow]
tags: [DP]
comments: true
---

top down LTE
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        def dp(n):
            if n == 0:
                return 0
            if n < 0 :
                return -1
            res = float('inf')
            for coin in coins:
                if dp(n-coin) < 0 :
                    continue 
                res = min(res,dp(n-coin)+1)
            return res if res != float('inf') else -1
        return dp(amount)

```


Top down solution
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # time O(NM), N = amount M = len(coins) ; space O(S)
        # step1: create a memo 
        memo = {}
        def dp(n):
            # step 2: check if n in memo
            if n in memo:
                return memo[n]
            # step 0 : base case1 -- if n == 0 
            if n == 0:
                return 0
            #step 0.5 : base case2 -- if n < 0
            if n < 0 :
                return -1
            # step3: initialize current decision var
            res = float('inf')
            # step4: solve subproblem-- loop through choices 
            for coin in coins:
                sub = dp(n-coin) # cache dp(n-coin) to sub can optimize runtime 
                # step4.1: early determination n-coin < 0 ==> return -1
                if sub == -1 :
                    continue
                # step4.2 update curren decision:  compare change or no change 
                res = min(res,sub+1)
                
            #step5 update final changes 
            memo[n] = res if res != float('inf') else -1
            
            return memo[n]
        
        return dp(amount)

```




Bottom up solution
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        # time O(kN) space O(N), N = amount, k = len(coins)
        # space O(N)
        # dp[i]: each ammount need mininum changes 
        # why initialize value is amount + 1 ?  because at most can all be changed with $1 coin. 
        # step1: initialize dp max val 
        dp = [amount + 1]  * (amount + 1)
        # step2: base case 
        dp[0] = 0
        # step3: loop dp 
        for i in range(len(dp)):
            #step3.2  iterate choices
            for coin in coins:
                #step3.3 early termination
                if i-coin < 0:
                    continue
                # step3.4 find current minimun coin change best choice
                dp[i] = min(dp[i-coin] +1,dp[i]) 
        # step4 check if dp[amount] changed, return valid dp[amount]
        return dp[amount] if dp[amount] != (amount + 1) else -1

################# non shorten space version
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        """tc O(KN) sc O(KN)
        main idea: Top Down  
        dp[i][j]: ways of COMBINATION to fill j amount with first time using coins[i-1]
        """
        n  = len(coins)
        dp = [[0 for x in range(amount+1)] for _ in range(n+1)]
        # base case 
        dp[0][0] = 1
        for i in range(1,n+1):
            dp[i][0] = 1
        for i in range(1,len(coins)+1):
            for j in range(1,amount+1):
                if j >= coins[i-1]:
                    # here use dp[i][j-coins[i-1]] instead of dp[i-1][j-coins[i-1]] 
                    # because it includes repeatedly using coin[i-1]
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
                else:
                    dp[i][j] = dp[i-1][j]
        return dp[n][amount]

```