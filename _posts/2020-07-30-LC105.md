---
layout: post
title: LC105 Construct Binary Tree from Preorder and Inorder Traversal
gh-badge: [star, fork, follow]
tags: [Tree,DFS, Array]
comments: true
---
[link](https://leetcode.com/problems/binary-tree-maximum-path-sum/)
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # time O(N) space(1)
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not inorder or not preorder:
            return None
        else:
            root_val = preorder.pop(0)
            idx = inorder.index(root_val)
            root = TreeNode(root_val)
            root.left = self.buildTree(preorder,inorder[0:idx])
            root.right = self.buildTree(preorder,inorder[idx+1:])
        return root
```

optimal
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    # time O(N) space(N)
    # main idea: to reduce time cost of list.pop(0) O(N) at each recursion, use iter to get the first number,  
    # to reduce the O(N) time cost of list.index(val), use dictionary to save index of inorder according to value  
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        inorder_d = {}
        for idx, num in enumerate(inorder):
            inorder_d[num] = idx
        pre_iter = iter(preorder)
        
        def helper(start,end):
            if start > end: return None
            root_val = next(pre_iter)
            root = TreeNode(root_val)
            idx = inorder_d[root.val]
            root.left = helper(start,idx-1)
            root.right = helper(idx+1,end)
            return root
        
        return helper(0,len(inorder)-1)
```


note:  time complexity of list.index(val)  is O(N)

straightforward solution
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        ni = len(inorder)
        np = len(preorder)
        if ni != np:
            return None 
        def helper(preorder,inorder,preL,preH,inL,inH):
            if preL > preH or inL > inH: return None 
            root = TreeNode(preorder[preL])
            
            inorder_root = inL
            for i in range(inL,inH+1):
                if inorder[i] == root.val:
                    inorder_root = i 
                    break
            
            leftTreeLen = inorder_root - inL 
            root.left = helper(preorder,inorder,preL+1,preL+leftTreeLen,inL,inorder_root-1)
            root.right = helper(preorder,inorder,preL+leftTreeLen+1,preH,inorder_root+1,inH)
            return root 
        return helper(preorder,inorder,0,np-1,0,np-1)
```