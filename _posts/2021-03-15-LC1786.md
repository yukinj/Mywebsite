```python
class Solution:
    def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
        """
        1.  dijkstra build graph 
        2.  start from nth node to ith node distance to make dis(i+1) < dis(i) ===> distance from current node to last node is strictly decreasing 
        dfs + memo 
        Dijkstra:  single source, non-negtive weight 
        Elg(E)
        what to memo?  
        pathNum(x1) = pathNum(x2) + pathNum(x3)+...
        pathNum(x2) = pathNum(x3) + ... 
        -  note here when we do dfs+memo, we don't do visited.  why???? each recursion. we favor lower dis 
                                        but for Dijkstra part we need visited 
        """
        M = 10**9+7
        # dijkstra 
        g = defaultdict(list)
        min_d = defaultdict(int)
        for s,e,d in edges:
            g[s].append([e,d])
            g[e].append([s,d])
        seen = set()
        pq = []
        heappush(pq,[0,n])
        while pq:
            d,cur = heappop(pq)
            if cur in seen:
                continue
            min_d[cur] = d 
            seen.add(cur)
            for nxt, dis in g[cur]:
                if nxt in seen:
                    continue
                heappush(pq,[dis+d,nxt])
        # dfs memo get total dis
        memo = {}
        def dfs(cur):
            # edge case 
            if cur == n:
                return 1
            if cur in memo:
                return memo[cur]
            sum_d = 0
            for nxt,dis in g[cur]:
                if min_d[nxt] >= min_d[cur]: continue
                sum_d += dfs(nxt)
                sum_d %= M
            memo[cur] = sum_d
            return sum_d
        res = dfs(1)
        return res  
                

```