---
layout: post
title: LC99   Recover Binary Search Tree
gh-badge: [star, fork, follow]
tags: [BST, DFS]
comments: true
---
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
"""
use inorder traversal, use pre ptr to cache posible abnomal fst node, so as to cache second abnomal node snd;  after all recursion end, switch fst and snd node's VALUE 
    1. inorder traversal, at cur node, before enter node.right, pre = node (cache by reference)
    2. find abnormal node where pre.val >= node.val , fill fst with pre; fill snd with node 
    3. after inorder recursion,  switch fst node's val  with snd node's val  
   

"""

    def recoverTree(self, root: TreeNode) -> None:
        if not root:
            return
        self.fst, self.snd,self.prev = None, None, TreeNode(float('-inf'))
        def inorder(node):
            if not node:
                return 
            inorder(node.left)
            # abnormal node :  self.prev.val >= node.val  
            if self.prev.val >= node.val:
                # there are two abnomal nodes in total, so need to record them both
                if not self.fst:
                    self.fst = self.prev
                self.snd = node
            self.prev = node   #prev store the root of subtree in this inorder traversal 
            inorder(node.right)
        inorder(root)
        self.fst.val, self.snd.val = self.snd.val,self.fst.val

```
[reference](https://leetcode.com/problems/recover-binary-search-tree/discuss/32535/No-Fancy-Algorithm-just-Simple-and-Powerful-In-Order-Traversal)